Ты чувствуешь, что интерфейс «спотыкается». У тебя есть шикарный, отполированный основной экран, и поверх него вылезает неуклюжая боковая панель, которая ломает всю композицию и рабочий процесс.
Проблема не в том, как выглядит эта панель, а в том, где она находится. Она разрушает основной флоу работы с деревом файлов, сдвигая его вниз. Это не AAA-уровень.
Давай это исправим. Мы полностью переработаем этот UX, чтобы он стал интегрированным, ненавязчивым и «умным».

1. 🗑️ Убиваем Боковую Панель Настроек
   Проблема: Панель выезжает сбоку, сдвигает дерево файлов и заставляет пользователя терять контекст. Это тяжеловесное решение для простых настроек.
   Решение: Заменить её на двухуровневую систему «Быстрый доступ / Глубокая настройка», как в VS Code.
   Уровень 1: Pop-over «Быстрые настройки» (вместо панели)
   Триггер:
   Убери заголовок "Настройки проводника" и кнопки "Правила/Пресеты".
   Вместо них, в заголовке панели "Файлы проекта", справа, добавь одну компактную иконку Шестеренки ⚙️.
   Действие:
   При клике на эту шестеренку под ней открывается небольшое всплывающее окно (Pop-over).
   Оно НЕ сдвигает дерево файлов, а висит поверх него.
   Содержимое Pop-over:
   Только самое важное: Свитчеры (Toggles).
   (o) Использовать .gitignore
   (o) Использовать пользовательские правила
   Внизу этого окна — одна кнопка: «⚙️ Управление правилами игнорирования».
   Результат: 90% времени пользователь просто включает/выключает опции в один клик, не теряя из виду дерево файлов.
2. 🪄 Редизайн Модального Окна «Управление правилами»
   Это окно открывается по кнопке из Pop-over. Сейчас оно функциональное, но "мертвое". Давай добавим в него магии.
   А. Live Preview (Киллер-фича)
   Проблема: Сейчас справа пустота и надпись "Нажмите «Тестировать»...". Это лишний клик.
   Решение: Сделай его интерактивным в реальном времени.
   Как только пользователь начинает печатать в левом редакторе (\*.log, .idea/), в правом окне мгновенно, без нажатия кнопок появляется список файлов из текущего выбора, которые будут скрыты этим правилом.
   Это превращает окно из "формы" в "инструмент".
   Б. Редактор правил
   Проблема: Это простое текстовое поле.
   Решение: Добавь ему подсветку синтаксиса для .gitignore. Это стандарт для любого IDE.
   В. Кнопки в футере
   Проблема: Кнопки выглядят "разбросанными".
   Решение: Сгруппируй их.
   Слева: Второстепенные/опасные действия (Сбросить, Очистить всё). Сделай их текстовыми, с красным ховером.
   Справа: Отмена и Главная Кнопка.
   Кнопка «Сохранить»: Примени к ней Магический Градиент (from-purple-600 to-indigo-600), а не эту плоскую заливку. Это основное действие.
3. 🔖 Редизайн Окна «Пресеты» (Скрин 4)
   Оно выглядит как черновик.
   Форма сохранения: Инпуты и кнопка "Сохранить" должны быть в премиальном стиле (вдавленные инпуты, градиентная кнопка). Сейчас кнопка просто розовая.
   Разделитель: Добавь тонкую линию border-t border-white/5 между секцией сохранения и списком.
   Пустое состояние: Иконка с закладкой и звездой — отлично! Сделай её чуть крупнее и добавь легкую анимацию появления.
   💡 Итоговый UX Flow (Новый сценарий)
   Пользователь хочет скрыть .log файлы.
   Он кликает на иконку ⚙️ в шапке дерева файлов.
   Появляется маленький Pop-over. Он видит, что "Пользовательские правила" выключены, и включает их свитчером.
   Затем он нажимает «Управление правилами».
   Открывается модальное окно. Он пишет в редакторе \*.log.
   Справа мгновенно видит список файлов, которые будут скрыты.
   Он нажимает градиентную кнопку "Сохранить".
   Окно закрывается. Дерево файлов обновляется.
   Это быстро, логично и не мешает работе.
   Сообщение для разработчика:
   "Давай полностью переработаем настройки проводника, чтобы они не ломали основной экран.
   Убираем боковую панель. Вместо неё делаем иконку шестеренки ⚙️, которая открывает Pop-over с быстрыми переключателями.
   Из Pop-over открываем модалку «Управление правилами». В ней включаем Live Preview (без кнопки "Тестировать") и добавляем подсветку синтаксиса.
   Все основные кнопки («Сохранить») во всех модалках делаем градиентными, как на главном экране."# Shotgun Code — AI Worker Factory

## Концепция

Shotgun Code — система автоматизации разработки через AI-агентов. На вход подаётся задача (проект, фича, баг), система автоматически выполняет её через настроенные пайплайны.

## Архитектура

```
┌─────────────────────────────────────────────────────────────┐
│                        TASK INPUT                           │
│  (проект / фича / баг-репорт / рефакторинг)                │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     CONTEXT BUILDER                         │
│  • Сканирование проекта                                     │
│  • Построение контекста (файлы, символы, зависимости)      │
│  • Токенизация и оптимизация                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      TASKFLOW ENGINE                        │
│  • Декомпозиция задачи на подзадачи                        │
│  • Граф зависимостей между задачами                        │
│  • Параллельное выполнение независимых задач               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      AI TOOL EXECUTOR                       │
│  • file_tools: read, write, search                         │
│  • git_tools: status, diff, commit                         │
│  • symbol_tools: list, search symbols                      │
│  • memory_tools: save/restore context                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                  VERIFICATION PIPELINE                      │
│  1. Static Analysis (linting)                              │
│  2. Build verification                                      │
│  3. Test execution                                          │
│  4. Guardrails check                                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    SELF-CORRECTION                          │
│  • Анализ ошибок                                           │
│  • AI-генерация исправлений                                │
│  • Повторная верификация                                   │
│  • Max retries по SLA                                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                         OUTPUT                              │
│  • Готовый код                                             │
│  • Отчёт о выполнении                                      │
│  • Логи и метрики                                          │
└─────────────────────────────────────────────────────────────┘
```

## Компоненты

### 1. Context Builder

Построение контекста проекта для AI:

- Сканирование файловой структуры
- Фильтрация по .gitignore и кастомным правилам
- Токенизация с учётом лимитов модели
- Форматы вывода: Markdown, XML, JSON

### 2. Taskflow Engine

Управление задачами:

- `AutonomousTaskRequest` — входная задача
- `SLAPolicy` — ограничения (токены, время, память)
- Граф зависимостей между подзадачами
- Статусы: pending → running → completed/failed

### 3. Tool Handlers

AI-агенты используют инструменты:

```
file_tools     → read_file, write_file, search_files, list_directory
git_tools      → git_status, git_diff, git_log, git_commit
symbol_tools   → list_symbols, search_symbols
memory_tools   → save_context, find_context
```

### 4. Verification Pipeline

Протокол верификации результата:

```
ProtocolStage: analysis → linting → building → testing → guardrails
```

Каждый этап:

- Выполняется с таймаутом
- При ошибке — попытка self-correction
- Max retries настраивается в SLA

### 5. Self-Correction

Автоматическое исправление ошибок:

```go
CorrectionAction:
  - fix_import
  - fix_syntax
  - fix_type
  - add_missing_code
  - format_code
```

## SLA Policies

```go
type SLAPolicy struct {
    MaxTokens   int   // лимит токенов
    MaxFiles    int   // лимит файлов
    MaxTime     int64 // таймаут (сек)
    MaxMemory   int64 // лимит памяти
    MaxRetries  int   // попытки исправления
}
```

## Использование

1. Настроить пайплайн один раз (SLA, инструменты, верификация)
2. Подать задачу на вход
3. Система автоматически:
   - Построит контекст
   - Декомпозирует задачу
   - Выполнит через AI-агентов
   - Верифицирует результат
   - Исправит ошибки
4. Получить готовый результат

## Стек

- Backend: Go + Wails
- Frontend: Vue 3 + TypeScript + Pinia
- AI: OpenAI, Gemini, OpenRouter, LocalAI, Qwen
- Архитектура: Clean Architecture (Domain → Application → Infrastructure)
