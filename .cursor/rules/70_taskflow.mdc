# Taskflow Rule (Shotgun)

## Основные принципы

- Всегда открывай tasks/plan.yaml. Выбирай первый task со статусом "todo", удовлетворяющий зависимостям.
- Не перескакивай задачи. После выполнения — обновляй tasks/status.json (id, state=done, summary, timestamp).
- Выполняй шаги из файла tasks/steps/*.yaml для выбранного task: по порядку, без пропусков.
- Возвращай ТОЛЬКО структурированные правки (Edits JSON / SAP) и следуй docs/schemas/edits.schema.json. Никаких git diff.

## MCP Usage and Acceptance

### Обязательные MCP-инструменты:
- **filesystem**: sandbox root = workspace; запрет абсолютных путей и ../
- **git**: status/commit/branch/worktree; без push по умолчанию
- **process**: allowlist: go, git, npm, node, tsc, eslint, prettier, rg/grep; таймауты/лимиты
- **search**: ripgrep/ctags

### Внешние вызовы:
- Любые внешние/сетевые вызовы и облачные LLM — ТОЛЬКО с requiresEscalation: true
- Context Pack + логирование provenance обязательны
- Memory (memory/Byteover) — только метаданные (current_task_id, last_error, iteration)

## Acceptance Pipeline

Для каждого шага выполняй acceptance в строгом порядке:

1. **Format** (если указан)
   - Примени форматирование кода
   - Проверь соответствие стилю

2. **Build/Type-check** (если указан mcp.build/check)
   - Вызови build.check(scope)
   - Проверь компиляцию/типизацию
   - Убедись в отсутствии ошибок

3. **Tests** (если указан mcp.test.run)
   - Вызови test.run(scope)
   - Проверь прохождение всех тестов
   - Убедись в покрытии кода

4. **Static Analysis** (если указан analyze/static)
   - Вызови analyze.static(scope)
   - Проверь линтеры и статические анализаторы
   - Убедись в качестве кода

5. **License** (если указан)
   - Проверь лицензионную совместимость
   - Убедись в отсутствии проблем с лицензиями

6. **Local Checks** (fileExists, grep)
   - Выполни локальные проверки как вспомогательные инструкции
   - Проверь наличие файлов и содержимое

## Repair Loop

Если acceptance не выполнен:
1. Сгенерируй минимальный repair Edits JSON
2. Примени исправления
3. Повтори acceptance
4. Максимум 2 итерации repair

## Quality Gates

### При успехе всего task:
- Отметь tasks/status.json с полной информацией
- Если требуется PR — подготовь derived diff и summary
- Не задавай интерактивных вопросов

### Бюджеты и ограничения:
- Уважай budgets (maxFiles, maxChangedLines) из tasks/plan.yaml
- При превышении → спросить подтверждение или завершить fail-closed
- Следи за forbid-путями и ограничениями
- Пороги качества (coverage/mutation) — конфигурируемые через budgets/policy

## Метрики качества

### Обязательные проверки:
- **Code Coverage**: минимум 80% для новых функций
- **Static Analysis**: 0 критических ошибок
- **Build Success**: 100% успешных сборок
- **Test Pass Rate**: 100% проходящих тестов

### Дополнительные метрики:
- **Complexity**: цикломатическая сложность < 10
- **Duplication**: дублирование кода < 5%
- **Documentation**: покрытие документацией > 90%

## Запрещено:
- Любые git diff
- Любые пути вне workspace, абсолютные пути, ../
- Изменение go.mod/package.json/lock/секретов без явного запроса
- Пропуск шагов acceptance pipeline
- Использование внешних вызовов без requiresEscalation: true
- Сохранение исходников/секретов в memory

## Советы:
- Контекст собирай по Retrieval Policy (LSP→SCIP→Graph→Embeddings)
- Для больших файлов — "умные вырезки"
- При генерации Edits JSON используй strategy: ast|symbol|anchor|fullFile (fullFile — крайний случай)
- Всегда указывай confidence и estimatedImpact в metadata
- Используй atomicGroup для связанных изменений
  
Советы:
- Контекст собирай по Retrieval Policy (LSP→SCIP→Graph→Embeddings).
- Для больших файлов — “умные вырезки”.
- При генерации Edits JSON используй strategy: ast|symbol|anchor|fullFile (fullFile — крайний случай).
  